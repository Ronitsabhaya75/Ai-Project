
[
    {
        "row_idx": 0,
        "row": {
            "id": 1,
            "slug": "two-sum",
            "title": "Two Sum",
            "difficulty": "Easy",
            "content": "Given an array of integers `nums` and an integer `target`, return _indices of the two numbers such that they add up to `target`_.\n\nYou may assume that each input would have **_exactly_ one solution**, and you may not use the _same_ element twice.\n\nYou can return the answer in any order.\n\n**Example 1:**\n\n**Input:** nums = \\[2,7,11,15\\], target = 9\n**Output:** \\[0,1\\]\n**Explanation:** Because nums\\[0\\] + nums\\[1\\] == 9, we return \\[0, 1\\].\n\n**Example 2:**\n\n**Input:** nums = \\[3,2,4\\], target = 6\n**Output:** \\[1,2\\]\n\n**Example 3:**\n\n**Input:** nums = \\[3,3\\], target = 6\n**Output:** \\[0,1\\]\n\n**Constraints:**\n\n*   `2 <= nums.length <= 104`\n*   `-109 <= nums[i] <= 109`\n*   `-109 <= target <= 109`\n*   **Only one valid answer exists.**\n\n**Follow-up:** Can you come up with an algorithm that is less than `O(n2)` time complexity?",
            "java": "\n    ```java\nimport java.util.HashMap;\nimport java.util.Map;\n\npublic int[] twoSum(int[] nums, int target) {\n    Map<Integer, Integer> map = new HashMap<>();\n    for (int i = 0; i < nums.length; i++) {\n        int complement = target - nums[i];\n        if (map.containsKey(complement)) {\n            return new int[]{map.get(complement), i};\n        }\n        map.put(nums[i], i);\n    }\n    throw new IllegalArgumentException(\"No two sum solution\");\n}\n```\n    \n    The algorithm leverages a hash map (unordered_map in C++, HashMap in Java, dictionary in Python, and Map in JavaScript). It iterates through the given 'nums' array and calculates the complementary value (target - current value). If the complementary value is already in the hash map, it means that we found a solution, and we return those indices. If the complement is not in the hash map, we store the current element in the hash map with its index. If the algorithm doesn't find the solution, it returns an empty array or throws an exception (in Java).\n\nThis approach has a time complexity of O(n) and a space complexity of O(n) as well.\n    ",
            "c++": "\n    ```cpp\n#include <vector>\n#include <unordered_map>\n\nstd::vector<int> twoSum(std::vector<int>& nums, int target) {\n    std::unordered_map<int, int> map;\n    for (int i = 0; i < nums.size(); i++) {\n        int complement = target - nums[i];\n        if (map.find(complement) != map.end()) {\n            return {map[complement], i};\n        }\n        map[nums[i]] = i;\n    }\n    return {};\n}\n```\n    \n    The algorithm leverages a hash map (unordered_map in C++, HashMap in Java, dictionary in Python, and Map in JavaScript). It iterates through the given 'nums' array and calculates the complementary value (target - current value). If the complementary value is already in the hash map, it means that we found a solution, and we return those indices. If the complement is not in the hash map, we store the current element in the hash map with its index. If the algorithm doesn't find the solution, it returns an empty array or throws an exception (in Java).\n\nThis approach has a time complexity of O(n) and a space complexity of O(n) as well.\n    ",
            "python": "\n    ```python\ndef twoSum(nums, target):\n    map = {}\n    for i, num in enumerate(nums):\n        complement = target - num\n        if complement in map:\n            return [map[complement], i]\n        map[num] = i\n    return []\n```\n    \n    The algorithm leverages a hash map (unordered_map in C++, HashMap in Java, dictionary in Python, and Map in JavaScript). It iterates through the given 'nums' array and calculates the complementary value (target - current value). If the complementary value is already in the hash map, it means that we found a solution, and we return those indices. If the complement is not in the hash map, we store the current element in the hash map with its index. If the algorithm doesn't find the solution, it returns an empty array or throws an exception (in Java).\n\nThis approach has a time complexity of O(n) and a space complexity of O(n) as well.\n    ",
            "javascript": "\n    ```javascript\nfunction twoSum(nums, target) {\n    const map = new Map();\n    for (let i = 0; i < nums.length; i++) {\n        const complement = target - nums[i];\n        if (map.has(complement)) {\n            return [map.get(complement), i];\n        }\n        map.set(nums[i], i);\n    }\n    return [];\n}\n```\n    \n    The algorithm leverages a hash map (unordered_map in C++, HashMap in Java, dictionary in Python, and Map in JavaScript). It iterates through the given 'nums' array and calculates the complementary value (target - current value). If the complementary value is already in the hash map, it means that we found a solution, and we return those indices. If the complement is not in the hash map, we store the current element in the hash map with its index. If the algorithm doesn't find the solution, it returns an empty array or throws an exception (in Java).\n\nThis approach has a time complexity of O(n) and a space complexity of O(n) as well.\n    "
        },
        "truncated_cells": []
    },
    {
        "row_idx": 1,
        "row": {
            "id": 2,
            "slug": "reverse-string",
            "title": "Reverse String",
            "difficulty": "Easy",
            "content": "Write a function that reverses a string. The input string is given as an array of characters `s`.\n\nYou must do this by modifying the input array [in-place](https://en.wikipedia.org/wiki/In-place_algorithm) with `O(1)` extra memory.\n\n**Example 1:**\n\n**Input:** s = [\"h\",\"e\",\"l\",\"l\",\"o\"]\n**Output:** [\"o\",\"l\",\"l\",\"e\",\"h\"]\n\n**Example 2:**\n\n**Input:** s = [\"H\",\"a\",\"n\",\"n\",\"a\",\"h\"]\n**Output:** [\"h\",\"a\",\"n\",\"n\",\"a\",\"H\"]\n\n**Constraints:**\n\n*   `1 <= s.length <= 105`\n*   `s[i]` is a [printable ascii character](https://en.wikipedia.org/wiki/ASCII#Printable_characters).",
            "java": "\n    ```java\npublic void reverseString(char[] s) {\n    int left = 0;\n    int right = s.length - 1;\n    while (left < right) {\n        char temp = s[left];\n        s[left] = s[right];\n        s[right] = temp;\n        left++;\n        right--;\n    }\n}\n```\n\nThis solution uses the two-pointer technique to reverse the string in place. We initialize two pointers, one at the beginning of the array and one at the end. Then, we swap the characters at these positions and move the pointers towards the middle until they meet. This approach has a time complexity of O(n) where n is the length of the string, and a space complexity of O(1) since we're not using any additional space proportional to the input size.\n    ",
            "c++": "\n    ```cpp\nclass Solution {\npublic:\n    void reverseString(vector<char>& s) {\n        int left = 0;\n        int right = s.size() - 1;\n        while (left < right) {\n            swap(s[left], s[right]);\n            left++;\n            right--;\n        }\n    }\n};\n```\n\nThis solution uses the two-pointer technique to reverse the string in place. We initialize two pointers, one at the beginning of the array and one at the end. Then, we swap the characters at these positions and move the pointers towards the middle until they meet. This approach has a time complexity of O(n) where n is the length of the string, and a space complexity of O(1) since we're not using any additional space proportional to the input size.\n    ",
            "python": "\n    ```python\nclass Solution:\n    def reverseString(self, s: List[str]) -> None:\n        \"\"\"\n        Do not return anything, modify s in-place instead.\n        \"\"\"\n        left, right = 0, len(s) - 1\n        while left < right:\n            s[left], s[right] = s[right], s[left]\n            left += 1\n            right -= 1\n```\n\nThis solution uses the two-pointer technique to reverse the string in place. We initialize two pointers, one at the beginning of the array and one at the end. Then, we swap the characters at these positions and move the pointers towards the middle until they meet. This approach has a time complexity of O(n) where n is the length of the string, and a space complexity of O(1) since we're not using any additional space proportional to the input size.\n    ",
            "javascript": "\n    ```javascript\nvar reverseString = function(s) {\n    let left = 0;\n    let right = s.length - 1;\n    while (left < right) {\n        [s[left], s[right]] = [s[right], s[left]];\n        left++;\n        right--;\n    }\n};\n```\n\nThis solution uses the two-pointer technique to reverse the string in place. We initialize two pointers, one at the beginning of the array and one at the end. Then, we swap the characters at these positions and move the pointers towards the middle until they meet. This approach has a time complexity of O(n) where n is the length of the string, and a space complexity of O(1) since we're not using any additional space proportional to the input size.\n    "
        },
        "truncated_cells": []
    },
    {
        "row_idx": 2,
        "row": {
            "id": 3,
            "slug": "palindrome-number",
            "title": "Palindrome Number",
            "difficulty": "Easy",
            "content": "Given an integer `x`, return `true` if `x` is a palindrome integer.\n\nAn integer is a **palindrome** when it reads the same backward as forward.\n\nFor example, `121` is a palindrome while `123` is not.\n\n**Example 1:**\n\n**Input:** x = 121\n**Output:** true\n**Explanation:** 121 reads as 121 from left to right and from right to left.\n\n**Example 2:**\n\n**Input:** x = -121\n**Output:** false\n**Explanation:** From left to right, it reads -121. From right to left, it becomes 121-. Therefore it is not a palindrome.\n\n**Example 3:**\n\n**Input:** x = 10\n**Output:** false\n**Explanation:** Reads 01 from right to left. Therefore it is not a palindrome.\n\n**Constraints:**\n\n*   `-231 <= x <= 231 - 1`\n\n**Follow up:** Could you solve it without converting the integer to a string?",
            "java": "\n    ```java\npublic boolean isPalindrome(int x) {\n    // Special cases:\n    // If x is negative, it's not a palindrome\n    // If x is positive and ends with 0, it's not a palindrome\n    if (x < 0 || (x % 10 == 0 && x != 0)) {\n        return false;\n    }\n    \n    int reversed = 0;\n    while (x > reversed) {\n        reversed = reversed * 10 + x % 10;\n        x /= 10;\n    }\n    \n    // When the length is odd, we can get rid of the middle digit by reversed/10\n    // For example when the input is 12321, at the end of the while loop we get x = 12, reversed = 123\n    return x == reversed || x == reversed / 10;\n}\n```\n\nThis solution avoids converting the integer to a string and instead uses mathematical operations to compare digits. We reverse the second half of the number and compare it with the first half. If they match (or match after removing the middle digit for odd-length numbers), then it's a palindrome. This has a time complexity of O(log n) where n is the input number, since we're processing each digit, and there are log10(n) digits in a number. The space complexity is O(1) as we use constant extra space.\n    ",
            "c++": "\n    ```cpp\nclass Solution {\npublic:\n    bool isPalindrome(int x) {\n        // Special cases:\n        // If x is negative, it's not a palindrome\n        // If x is positive and ends with 0, it's not a palindrome\n        if (x < 0 || (x % 10 == 0 && x != 0)) {\n            return false;\n        }\n        \n        int reversed = 0;\n        while (x > reversed) {\n            reversed = reversed * 10 + x % 10;\n            x /= 10;\n        }\n        \n        // When the length is odd, we can get rid of the middle digit by reversed/10\n        // For example when the input is 12321, at the end of the while loop we get x = 12, reversed = 123\n        return x == reversed || x == reversed / 10;\n    }\n};\n```\n\nThis solution avoids converting the integer to a string and instead uses mathematical operations to compare digits. We reverse the second half of the number and compare it with the first half. If they match (or match after removing the middle digit for odd-length numbers), then it's a palindrome. This has a time complexity of O(log n) where n is the input number, since we're processing each digit, and there are log10(n) digits in a number. The space complexity is O(1) as we use constant extra space.\n    ",
            "python": "\n    ```python\nclass Solution:\n    def isPalindrome(self, x: int) -> bool:\n        # Special cases:\n        # If x is negative, it's not a palindrome\n        # If x is positive and ends with 0, it's not a palindrome\n        if x < 0 or (x % 10 == 0 and x != 0):\n            return False\n        \n        reversed_num = 0\n        while x > reversed_num:\n            reversed_num = reversed_num * 10 + x % 10\n            x //= 10\n        \n        # When the length is odd, we can get rid of the middle digit by reversed_num//10\n        # For example when the input is 12321, at the end of the while loop we get x = 12, reversed_num = 123\n        return x == reversed_num or x == reversed_num // 10\n```\n\nThis solution avoids converting the integer to a string and instead uses mathematical operations to compare digits. We reverse the second half of the number and compare it with the first half. If they match (or match after removing the middle digit for odd-length numbers), then it's a palindrome. This has a time complexity of O(log n) where n is the input number, since we're processing each digit, and there are log10(n) digits in a number. The space complexity is O(1) as we use constant extra space.\n    ",
            "javascript": "\n    ```javascript\nvar isPalindrome = function(x) {\n    // Special cases:\n    // If x is negative, it's not a palindrome\n    // If x is positive and ends with 0, it's not a palindrome\n    if (x < 0 || (x % 10 === 0 && x !== 0)) {\n        return false;\n    }\n    \n    let reversed = 0;\n    let original = x;\n    \n    while (x > 0) {\n        reversed = reversed * 10 + x % 10;\n        x = Math.floor(x / 10);\n    }\n    \n    return original === reversed;\n};\n```\n\nThis solution avoids converting the integer to a string and instead uses mathematical operations to compare digits. We reverse the entire number and compare it with the original. If they match, then it's a palindrome. This has a time complexity of O(log n) where n is the input number, since we're processing each digit, and there are log10(n) digits in a number. The space complexity is O(1) as we use constant extra space.\n    "
        },
        "truncated_cells": []
    }
]
